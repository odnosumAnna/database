                                                  Практична робота 4
                                                  
Мета роботи: Метою даної роботи є ознайомлення з концепцією функцій у MSSQL, зокрема скалярних та віконних функцій, та їх застосування у практичних запитах. Робота передбачає вивчення можливостей скалярних функцій для обробки та трансформації даних у базах даних.

                                             Варіант №20 (ДАІ)
База даних повинна містити інформацію про дорожньо-транспортні
подіях (ДТП). Про ДТП має бути відомо вид ДТП, які транспортні засоби в ньому брали участь (можливо більше двох), їх державні номери, П.І.Б., домашні адреси водіїв цих транспортних засобів, а також номери посвідчень водія. Крімтого, необхідно знати кількість постраждалих у даній ДТП, вид травми, П.І.Б., домашня адреса та номер паспорта кожного потерпілого. Постраждалими можуть бути водії. У ДТП можуть брати участь і пішоходи, про які потрібно знати, чи не є вони постраждалими, а також їх П.І.Б., домашню адресу та номер паспорта. Про ДТП також мають бути відомі місце, дата, час, винуватець ДТП та які міліціонери (їх звання та П.І.Б.) виїжджали ДТП.
                          
                                Запити
        •	Вивести повний список ДТП, які виникли з вини пішоходів, за вказаний
        період з повними відомостями про них;
        •	Знайти місце, де сталася максимальна кількість ДТП;
        •	Вивести повний список ДТП, на які ВИЇжджали міліціонери із зазначеним
        званням за вказаний період часу, з повними відомостями про ДТП;
        •	Скласти список водіїв, які брали участь більше НІЖ В ОДНІЙ ДТП за
        зазначений період часу, З повними відомостями про цих водіїв;
        •	Скласти список постраждалих у ДТП за вказаний період часу з
        повними відомостями про ці ДТП, упорядковані за кількістю травм певного виду.
        •	Внести відомості про нову ДТП;
        •	Видалити відомості про ДТП, які сталися раніше вказаної дати.

                            
                        Логічна та фізична модель
![image](https://github.com/user-attachments/assets/f28b2ca6-c263-4cf1-8a6b-23382d8fbcb9)

![image](https://github.com/user-attachments/assets/96d46b57-0b9a-4983-97ca-c6d99bad622c)



Завдання 2. Агрегатна функція COUNT()
-- Підрахунок кількості записів у таблиці Accident
SELECT 'Accident' AS TableName, COUNT(*) AS RecordCount
FROM Accident;

-- Підрахунок кількості записів у таблиці Driver_Involvement
SELECT 'Driver_Involvement' AS TableName, COUNT(*) AS RecordCount
FROM Driver_Involvement;

-- Підрахунок кількості записів у таблиці Vehicle
SELECT 'Vehicle' AS TableName, COUNT(*) AS RecordCount
FROM Vehicle;

-- Підрахунок кількості записів у таблиці Driver
SELECT 'Driver' AS TableName, COUNT(*) AS RecordCount
FROM Driver;

-- Підрахунок кількості записів у таблиці Policeman
SELECT 'Policeman' AS TableName, COUNT(*) AS RecordCount
FROM Policeman;

-- Підрахунок кількості записів у таблиці Victim
SELECT 'Victim' AS TableName, COUNT(*) AS RecordCount
FROM Victim;

-- Підрахунок кількості записів у таблиці Pedestrian
SELECT 'Pedestrian' AS TableName, COUNT(*) AS RecordCount
FROM Pedestrian;

-- Підрахунок кількості записів у таблиці Culprit
SELECT 'Culprit' AS TableName, COUNT(*) AS RecordCount
FROM Culprit;

![image](https://github.com/user-attachments/assets/bdd54784-4943-4e26-92f0-aa2f8fb08629)

                      Рисунок  4 – виконання завдання 2.

Завдання 3. Використання агрегатних функцій

Запит 1: Підрахунок загальної кількості постраждалих у всіх ДТП

SELECT SUM(Victim_Count) AS TotalVictims FROM Accident;
Аналіз запиту:
•	SUM(Victim_Count) – агрегатна функція, яка підсумовує всі значення в стовпці Victim_Count (кількість постраждалих у ДТП).
•	AS TotalVictims – задає назву для виведеного стовпця.
•	FROM Accident – визначає таблицю, з якої беруться дані.
 Результат: загальна кількість постраждалих у всіх зафіксованих ДТП.

Запит 2: Середній рік випуску транспортних засобів

SELECT AVG(Year) AS AverageVehicleYear FROM Vehicle;
Аналіз запиту:
•	AVG(Year) – агрегатна функція, яка обчислює середній рік випуску автомобілів.
•	AS AverageVehicleYear – встановлює ім’я для вихідного стовпця.
•	FROM Vehicle – джерело даних для обчислення.
 Результат: середній рік випуску всіх зареєстрованих у ДТП транспортних засобів.

Запит 3: Пошук найновішого та найстарішого транспортного засобу

SELECT MAX(Year) AS NewestVehicle, MIN(Year) AS OldestVehicle FROM Vehicle;
Аналіз запиту:
•	MAX(Year) – повертає найбільше значення з колонки Year (найновіший автомобіль).
•	MIN(Year) – повертає найменше значення з колонки Year (найстаріший автомобіль).
•	AS NewestVehicle, AS OldestVehicle – задають назви для виведених стовпців.
•	FROM Vehicle – джерело даних.
 Результат: знайдено рік випуску найновішого та найстарішого автомобіля в базі.

![image](https://github.com/user-attachments/assets/6898f124-0e0f-4109-9deb-1f969f908d11)

 
                        Рисунок  5 – виконання завдання 3.
                        
Завдання 4. Запити з використанням віконних функцій

Запит 1: Нумерація ДТП за датою

SELECT ID_Accident, Date, 
       ROW_NUMBER() OVER (ORDER BY Date) AS AccidentNumber
FROM Accident;
Аналіз запиту:
•	ROW_NUMBER() OVER (ORDER BY Date) – пронумеровує всі ДТП у порядку зростання дати.
•	OVER (ORDER BY Date) – визначає, що нумерація буде йти за датою.
•	AS AccidentNumber – задає назву для стовпця з номером ДТП.
 Результат: кожній ДТП присвоєно унікальний порядковий номер.
 
Запит 2: Визначення кількості постраждалих у кожній ДТП та середньої кількості по всій таблиці

SELECT ID_Accident, Victim_Count, 
       AVG(Victim_Count) OVER () AS AvgVictimCount
FROM Accident;
Аналіз запиту:
•	AVG(Victim_Count) OVER () – обчислює середню кількість постраждалих у всіх ДТП, але виводить це значення у кожному рядку.
•	OVER () – означає, що середнє обчислюється по всій таблиці.
 Результат: у кожному рядку міститься кількість постраждалих у конкретному ДТП та середнє значення по всіх ДТП.
 
Запит 3: Обчислення кількості ДТП до поточного рядка (з накопиченням)

SELECT ID_Accident, Date, 
       COUNT(ID_Accident) OVER (ORDER BY Date ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS CumulativeAccidents
FROM Accident;
Аналіз запиту:
•	COUNT(ID_Accident) OVER (...) – підраховує кількість ДТП.
•	ORDER BY Date – ДТП обробляються у порядку зростання дати.
•	ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW – підрахунок включає всі ДТП до поточного рядка.
 Результат: кожен рядок показує, скільки ДТП сталося до поточної дати (накопичення).

 
  ![image](https://github.com/user-attachments/assets/6d6a9958-95db-402a-b7e7-9bcb3ef5e63f)

                              Рисунок  6 – виконання завдання 4
Завдання 5: Запити з використанням рядкових функцій

Запит 1: Перетворення імен водіїв у верхній регістр

SELECT ID_Driver, FirstName, LastName, 
       UPPER(FirstName) AS UpperFirstName, 
       UPPER(LastName) AS UpperLastName
FROM Driver;
Аналіз запиту:
•	UPPER(FirstName), UPPER(LastName) – переводять імена у верхній регістр.
 Результат: виводить імена водіїв як у вихідному вигляді, так і у верхньому регістрі.

Запит 2: Витягування серії та номера водійського посвідчення

SELECT ID_Driver, License_Number, 
       LEFT(License_Number, 2) AS LicenseSeries, 
       RIGHT(License_Number, 6) AS LicenseNumber
FROM Driver;
Аналіз запиту:
•	LEFT(License_Number, 2) – отримує перші два символи (серію).
•	RIGHT(License_Number, 6) – отримує останні 6 символів (номер посвідчення).
 Результат: у кожному рядку відображається серія та номер водійського посвідчення окремо.
 
Запит 3: Видалення пробілів з номера автомобіля

SELECT ID_Vehicle, License_Plate, 
       TRIM(License_Plate) AS TrimmedLicensePlate
FROM Vehicle;
Аналіз запиту:
•	TRIM(License_Plate) – видаляє зайві пробіли з номера автомобіля.
 Результат: повертає номерні знаки без зайвих пробілів.

![image](https://github.com/user-attachments/assets/1c8483d9-f473-420d-b55a-aa4698aa757b)

                      Рисунок  7 – виконання завдання 5
                      
Завдання 6: Запити з використанням функцій для обробки дати
Функції для роботи з датою дозволяють отримувати поточну дату, додавати дні, визначати різницю між датами тощо.

Запит 1: Визначення віку водійського посвідчення

SELECT ID_Driver, License_Number, License_Expiry, 
       DATEDIFF(DAY, GETDATE(), License_Expiry) AS DaysUntilExpiry,
       CASE 
           WHEN DATEDIFF(DAY, GETDATE(), License_Expiry) < 0 THEN 'Expired'
           ELSE 'Valid'
       END AS Status
FROM Driver;
Поелементний аналіз:
•	ID_Driver – унікальний ідентифікатор водія.
•	License_Number – номер водійського посвідчення.
•	License_Expiry – дата закінчення строку дії посвідчення.
•	DATEDIFF(DAY, GETDATE(), License_Expiry) – обчислює кількість днів між поточною датою (GETDATE()) та датою закінчення дії водійського посвідчення.
o	Якщо значення додатне – посвідчення ще дійсне.
o	Якщо від’ємне – посвідчення прострочене.
•	CASE ... END AS Status – перевіряє, чи DaysUntilExpiry від'ємне, і встановлює статус:
o	'Expired' – якщо посвідчення прострочене.
o	'Valid' – якщо посвідчення ще дійсне.

Запит 2: Визначення дня тижня для кожного ДТП

SELECT ID_Accident, Date, 
       DATENAME(WEEKDAY, Date) AS AccidentDay
FROM Accident;
Аналіз запиту:
•	DATENAME(WEEKDAY, Date) – повертає день тижня для кожної ДТП (наприклад, "Monday").
 Результат: показує, в який день тижня сталося кожне ДТП.
 
Запит 3: Додавання 7 днів до дати ДТП (для прогнозу наслідків)

SELECT ID_Accident, Date, 
       DATEADD(DAY, 7, Date) AS FollowUpDate
FROM Accident;
Аналіз запиту:
•	DATEADD(DAY, 7, Date) – додає 7 днів до дати ДТП.
 Результат: прогнозована дата контрольного огляду ДТП через тиждень.
 
 ![image](https://github.com/user-attachments/assets/b6c7a537-92dd-455d-a090-e75845589617)

                                Рисунок  8 – виконання завдання 6

Висновки: 
У ході виконання роботи я ознайомилась з концепцією функцій у MSSQL, зокрема скалярних та віконних функцій, та їх застосування у практичних запитах. Робота передбачає вивчення можливостей скалярних функцій для обробки та трансформації даних у базах даних.


