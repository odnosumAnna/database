                                                 ПРАКТИЧНА РОБОТА №6
          	                        на тему: « Поняття транзакцій й робота з ними в MSSQL.»
                                 
Мета роботи: Ознайомитися з поняттям індексів у системі керування базами даних Microsoft SQL Server, вивчити їх призначення, особливості використання та вплив на продуктивність запитів. Засвоїти оператори створення індексів, порядок їх застосування, а також методи реорганізації та видалення. Набути практичних навичок роботи з індексами шляхом створення, оптимізації та аналізу їх ефективності у базі даних.

                                             Варіант №20 (ДАІ)
База даних повинна містити інформацію про дорожньо-транспортні
подіях (ДТП). Про ДТП має бути відомо вид ДТП, які транспортні засоби в ньому брали участь (можливо більше двох), їх державні номери, П.І.Б., домашні адреси водіїв цих транспортних засобів, а також номери посвідчень водія. Крімтого, необхідно знати кількість постраждалих у даній ДТП, вид травми, П.І.Б., домашня адреса та номер паспорта кожного потерпілого. Постраждалими можуть бути водії. У ДТП можуть брати участь і пішоходи, про які потрібно знати, чи не є вони постраждалими, а також їх П.І.Б., домашню адресу та номер паспорта. Про ДТП також мають бути відомі місце, дата, час, винуватець ДТП та які міліціонери (їх звання та П.І.Б.) виїжджали ДТП.
                          
                                Запити
        •	Вивести повний список ДТП, які виникли з вини пішоходів, за вказаний
        період з повними відомостями про них;
        •	Знайти місце, де сталася максимальна кількість ДТП;
        •	Вивести повний список ДТП, на які ВИЇжджали міліціонери із зазначеним
        званням за вказаний період часу, з повними відомостями про ДТП;
        •	Скласти список водіїв, які брали участь більше НІЖ В ОДНІЙ ДТП за
        зазначений період часу, З повними відомостями про цих водіїв;
        •	Скласти список постраждалих у ДТП за вказаний період часу з
        повними відомостями про ці ДТП, упорядковані за кількістю травм певного виду.
        •	Внести відомості про нову ДТП;
        •	Видалити відомості про ДТП, які сталися раніше вказаної дати.

                            
                        Логічна та фізична модель
![image](https://github.com/user-attachments/assets/f28b2ca6-c263-4cf1-8a6b-23382d8fbcb9)

![image](https://github.com/user-attachments/assets/96d46b57-0b9a-4983-97ca-c6d99bad622c)


Завдання 2. Транзакція у базі даних.
Транзакція – це логічна одиниця роботи, що складається з однієї або більше операцій маніпулювання даними (SELECT, INSERT, UPDATE, DELETE), яка розглядається СКБД як єдине ціле. 
Основне призначення транзакцій – переведення бази даних з одного узгодженого стану в інший узгоджений стан, навіть якщо для цього потрібно виконати кілька фізичних операцій. Наприклад, коли до бази додається новий співробітник, окрім самої операції вставки (INSERT), може також знадобитися оновити лічильник співробітників у певному відділі (UPDATE DeptCount). Ключовою характеристикою транзакції є принцип "все або нічого": або всі операції всередині транзакції успішно виконуються і їхні зміни стають постійними (COMMIT), або жодна з операцій не впливає на базу даних, і система повертається до стану, який був до початку транзакції (ROLLBACK).

Ключові властивості транзакції можна описати за допомогою абревіатури ACID:
1.	Atomicity (атомарність) — або всі операції транзакції виконуються успішно, або жодна з них не має ефекту. У випадку помилки виконується відкат (ROLLBACK).
2.	Consistency (узгодженість) — транзакція переводить базу з одного узгодженого стану в інший.
3.	Isolation (ізольованість) — паралельні транзакції не повинні заважати одна одній, зміни однієї не бачать інші, поки вона не завершиться.
4.	Durability (стійкість) — після завершення транзакції її результати зберігаються в базі навіть у випадку збоїв системи.
Завершення транзакції відбувається двома способами:
•	COMMIT — підтвердження всіх змін і збереження їх у базі;
•	ROLLBACK — відміна всіх змін, виконаних під час транзакції, і повернення бази до початкового стану.
Таким чином, транзакції є фундаментальним механізмом для гарантування цілісності, надійності та правильності роботи бази даних у багатокористувацькому та часто змінюваному середовищі.
Завдання 3. Використання транзакції за варіантом завдання про ДАІ.
 В цьому завданні розглядаю використання транзакцій у базі даних для збереження цілісності даних при внесенні нового запису про ДТП та відповідних учасників. Транзакція забезпечує атомарність всіх операцій: або всі дані додаються до бази, або жодна з операцій не виконується у разі помилки. Це дозволяє уникнути ситуації, коли частина даних була додана, а інша частина — ні, що може призвести до неконсистентності.



Лістинг коду:
BEGIN TRANSACTION;

-- 1. Додавання нової інформації про ДТП
DECLARE @NewAccidentID INT;

-- Додаємо основні дані про ДТП
INSERT INTO Accident (Date, Time, Location, Victim_Count, Accident_Type, Investigation_Status)
VALUES ('2023-05-15', '14:30:00', 'Central St, 25', 2, 'Two-car collision', 'Under investigation');

-- Отримуємо ID нової ДТП
SET @NewAccidentID = SCOPE_IDENTITY();

-- Додаємо дані про водіїв
INSERT INTO Driver (LastName, FirstName, MiddleName, Address, License_Number, License_Expiry, Phone)
VALUES ('Ivanov', 'Petro', 'Sergiyovych', 'Forest St, 10', 'AB123456', '2025-12-31', '+380501234567');

DECLARE @Driver1ID INT = SCOPE_IDENTITY();

INSERT INTO Driver (LastName, FirstName, MiddleName, Address, License_Number, License_Expiry, Phone)
VALUES ('Petrov', 'Oleksiy', 'Ivanovych', 'Garden St, 5', 'BC654321', '2024-10-15', '+380671234567');

DECLARE @Driver2ID INT = SCOPE_IDENTITY();

-- Додаємо транспортні засоби
INSERT INTO Vehicle (ID_Accident, License_Plate, Model, Year)
VALUES (@NewAccidentID, 'AA1234BC', 'Toyota Camry', 2018);

INSERT INTO Vehicle (ID_Accident, License_Plate, Model, Year)
VALUES (@NewAccidentID, 'BC5678AA', 'Honda Civic', 2020);

-- Додаємо участь водіїв у ДТП
INSERT INTO Driver_Involvement (ID_Accident, ID_Driver, Role, Involvement_Status, Fixation_Time)
VALUES (@NewAccidentID, @Driver1ID, 'Participant', 'Registered', GETDATE());

INSERT INTO Driver_Involvement (ID_Accident, ID_Driver, Role, Involvement_Status, Fixation_Time)
VALUES (@NewAccidentID, @Driver2ID, 'Participant', 'Registered', GETDATE());

-- Додаємо дані про постраждалих
INSERT INTO Victim (ID_Accident, LastName, FirstName, MiddleName, Address, Passport_Number, Injury_Type, Severity, Hospitalization_Status)
VALUES (@NewAccidentID, 'Ivanov', 'Petro', 'Sergiyovych', 'Forest St, 10', 'KM123456', 'Arm fracture', 'Moderate', 'Hospitalized');

INSERT INTO Victim (ID_Accident, LastName, FirstName, MiddleName, Address, Passport_Number, Injury_Type, Severity, Hospitalization_Status)
VALUES (@NewAccidentID, 'Sydorenko', 'Maria', 'Olehivna', 'Park St, 15', 'KM654321', 'Brain concussion', 'Severe', 'Hospitalized');

-- Додаємо дані про пішохода (винуватця)
INSERT INTO Pedestrian (ID_Accident, LastName, FirstName, MiddleName, Address, Passport_Number, Is_Victim, Phone)
VALUES (@NewAccidentID, 'Kovalenko', 'Andriy', 'Volodymyrovych', 'Shevchenko St, 20', 'KM987654', 0, '+380631234567');

-- Додаємо винуватця ДТП (пішохід)
INSERT INTO Culprit (ID_Related, ID_Accident, Type)
VALUES (SCOPE_IDENTITY(), @NewAccidentID, 'Pedestrian');

-- Додаємо дані про поліцейських
INSERT INTO Policeman (ID_Accident, LastName, FirstName, MiddleName, Rank, Department)
VALUES (@NewAccidentID, 'Boyko', 'Oleh', 'Mykhailovych', 'Senior Lieutenant', 'Kyiv Traffic Police');

INSERT INTO Policeman (ID_Accident, LastName, FirstName, MiddleName, Rank, Department)
VALUES (@NewAccidentID, 'Shevchenko', 'Vitaliy', 'Ihorovych', 'Lieutenant', 'Kyiv Traffic Police');

-- Перевіряємо наявність помилок
IF @@ERROR = 0
BEGIN
    COMMIT TRANSACTION;
    PRINT 'Transaction completed successfully. New accident data added to database.';
END
ELSE
BEGIN
    ROLLBACK TRANSACTION;
    PRINT 'Error occurred during transaction. All changes have been rolled back.';
END;
Пояснення транзакції:
1.	Початок транзакції:
o	BEGIN TRANSACTION ініціалізує транзакцію. Це означає, що всі операції, що виконуються в рамках цієї транзакції, будуть або всі успішними, або жодна не буде зафіксована в базі даних, якщо виникне помилка.
2.	Додавання даних:
o	Основні дані про ДТП: Додається запис з інформацією про ДТП, включаючи дату, час, місце, тип ДТП та статус розслідування.
o	Інформація про водіїв: Додаються дані двох водіїв, зокрема їхні ПІБ, адреси, номери водійських посвідчень, телефони тощо.
o	Транспортні засоби: Додаються дані про автомобілі, що брали участь у ДТП, включаючи їхні номерні знаки, моделі та роки випуску.
o	Участь водіїв у ДТП: Додаються записи про участь водіїв у ДТП, де зазначається їх роль та статус участі.
o	Дані про постраждалих: Додаються записи про постраждалих осіб, включаючи ПІБ, тип травм, тяжкість та статус госпіталізації.
o	Інформація про пішохода (винуватця): Додається запис про пішохода, який був винуватцем ДТП.
o	Дані про поліцейських: Додаються записи про поліцейських, які виїхали на місце події.
3.	Фіксація або відкат транзакції:
o	Якщо всі операції виконуються без помилок (перевірка через @@ERROR), то транзакція фіксується за допомогою COMMIT TRANSACTION.
o	У разі помилки в будь-якій операції всі зміни скасовуються за допомогою ROLLBACK TRANSACTION, і виводиться повідомлення про помилку.
Транзакція гарантує, що або всі дані будуть коректно внесені в базу даних, або жодних змін не відбудеться, якщо виникне помилка. Це важливо для забезпечення цілісності даних.
   


Завдання 4. Реалізація транзакції з двома операціями та умовою, яка призведе до ROLLBACK.
У цьому завданні я реалізую транзакцію, що містить дві основні операції: оновлення статусу розслідування для певної ДТП та перевірку наявності пішохода, який є винуватцем. Якщо умова виконання перевірки не буде задоволена (тобто не знайдено пішохода-винуватця), то транзакція буде скасована за допомогою операції ROLLBACK. Якщо ж умова виконується, транзакція буде підтверджена за допомогою операції COMMIT.
Цей підхід дозволяє забезпечити цілісність даних: якщо одна з операцій не виконується, то всі зміни будуть скасовані, що гарантує коректність і надійність обробки даних у базі.
Лістинг коду:
BEGIN TRAN;

-- Оновлюємо статус розслідування для ДТП з ID = 1
UPDATE Accident
SET Investigation_Status = 'Closed'
WHERE ID_Accident = 1;

-- Якщо немає жодного пішохода, який є винуватцем — відкат
IF (SELECT COUNT(*) FROM Culprit WHERE Type = 'Pedestrian') = 0
    ROLLBACK;
ELSE
    COMMIT;

Пояснення коду:
1.	BEGIN TRAN; — Ініціалізація транзакції. Це означає, що всі зміни в межах цієї транзакції будуть або підтверджені, або скасовані разом.
2.	UPDATE Accident SET Investigation_Status = 'Closed' WHERE ID_Accident = 1; — Оновлення статусу розслідування для ДТП з ID = 1 на "Closed". Це перша операція транзакції.
3.	IF (SELECT COUNT(*) FROM Culprit WHERE Type = 'Pedestrian') = 0 ROLLBACK; — Перевірка, чи є в таблиці Culprit пішохід, який є винуватцем. Якщо таких пішоходів немає (кількість = 0), то транзакція скасовується за допомогою ROLLBACK.
4.	ELSE COMMIT; — Якщо в таблиці є пішохід-винуватець, то транзакція підтверджується через COMMIT.
Транзакція забезпечує цілісність даних: якщо не виконано умови (немає пішохода-винуватця), всі зміни скасовуються, щоб не зберігалися неповні або некоректні дані.
  

Завдання 5. Перевірка @@ERROR для керування транзакцією.
У цьому завданні я реалізувала транзакцію з використанням системної змінної @@ERROR для контролю помилок під час виконання SQL-операцій. Код перевіряє, чи сталася помилка під час оновлення даних про ДТП, і відповідно виконує ROLLBACK або COMMIT.
Лістинг коду:
BEGIN TRAN;

-- Спроба оновлення дати ДТП (можливо неіснуючого запису)
UPDATE Accident
SET Date = '2025-01-01'
WHERE ID_Accident = 9999;

-- Якщо сталася помилка — відкочуємо транзакцію
IF @@ERROR <> 0
    ROLLBACK;
ELSE
    COMMIT;
Пояснення до коду :
1.	BEGIN TRAN; — початок транзакції.
2.	UPDATE Accident SET Date = '2025-01-01' WHERE ID_Accident = 9999;
— спроба оновити запис про ДТП з неіснуючим ID. Це потенційно викличе помилку.
3.	IF @@ERROR <> 0 ROLLBACK;
— якщо під час оновлення виникла помилка, транзакція скасовується.
4.	ELSE COMMIT;
— якщо помилки не було, зміни підтверджуються.
Такий підхід забезпечує контроль за цілісністю даних та дозволяє уникнути частково виконаних змін.



Завдання 6. Точка збереження у транзакції.
У цьому завданні я реалізувала використання точки збереження (SAVE TRANSACTION) у середині транзакції. Це дозволяє частково відкотити транзакцію до певного моменту без втрати попередніх змін. Такий підхід зручний, якщо потрібно перевірити деякі дії перед остаточним підтвердженням усієї транзакції.
Лістинг коду:
BEGIN TRAN;

-- Зберігаємо точку перед оновленням
SAVE TRANSACTION BeforeUpdate;

-- Оновлення адреси водія
UPDATE Driver
SET Address = 'New Address, Kyiv'
WHERE ID_Driver = 2;

-- Відкат до точки збереження (зміни не застосуються)
ROLLBACK TRANSACTION BeforeUpdate;

-- Підтверджуємо всі попередні дії до точки збереження
COMMIT;



Пояснення до коду:
1.	BEGIN TRAN; — початок транзакції.
2.	SAVE TRANSACTION BeforeUpdate; — створення точки збереження з назвою BeforeUpdate.
3.	UPDATE Driver... — зміна адреси водія з ID = 2.
4.	ROLLBACK TRANSACTION BeforeUpdate; — відкат саме до точки збереження (оновлення адреси скасовується, але транзакція не завершується повністю).
5.	COMMIT; — підтвердження всіх змін, зроблених до точки BeforeUpdate.
Цей механізм дозволяє гнучко керувати транзакцією та уникати повного скасування змін при необхідності.
 

Завдання 7. TRY...CATCH у транзакції.
У цьому завданні я реалізувала обробку помилок під час виконання транзакції за допомогою конструкції TRY...CATCH. Такий підхід дозволяє безпечно виконувати SQL-операції й автоматично обробляти винятки, що можуть виникнути, наприклад, через неправильні дані.
Лістинг коду:
BEGIN TRAN;

BEGIN TRY
    -- Спроба вставити некоректну дату — викликає помилку
    UPDATE Accident
    SET Date = 'invalid-date'
    WHERE ID_Accident = 1;

    COMMIT;
END TRY
BEGIN CATCH
    ROLLBACK;
    PRINT ERROR_MESSAGE();
END CATCH;

Пояснення до коду:
1.	BEGIN TRAN; — початок транзакції.
2.	BEGIN TRY ... END TRY — в цьому блоці виконується спроба оновити дату ДТП. Значення 'invalid-date' не є коректною датою, тому викликається помилка.
3.	COMMIT; — фіксація змін, якщо помилки не сталося (в цьому випадку не виконається).
4.	BEGIN CATCH ... END CATCH — при виникненні помилки виконується відкат транзакції (ROLLBACK) і виводиться повідомлення про помилку (PRINT ERROR_MESSAGE();).
Цей механізм забезпечує контрольоване завершення транзакції навіть при виникненні помилок.
 

Завдання 8. Сценарій BEGIN TRAN ... COMMIT з логуванням змін.
У цьому завданні реалізую транзакцію, яка не лише оновлює дані у таблиці, а й фіксує відповідну інформацію про зміну в окремій таблиці журналу (audit_log). Такий підхід дозволяє краще контролювати всі операції в базі даних та забезпечити їх відстеження.
Лістинг коду:

CREATE TABLE audit_log (
    ID INT PRIMARY KEY IDENTITY(1,1),
    Action VARCHAR(255) NOT NULL,
    Timestamp DATETIME NOT NULL
);


BEGIN TRAN;

-- Оновлення даних водія ( змінюємо ім'я водія)
UPDATE Driver
SET FirstName = 'Ivan'
WHERE ID_Driver = 1;  

-- Логування змін
INSERT INTO Audit_Log (Action, Timestamp)
VALUES ('Updated driver first name to Ivan', GETDATE());

COMMIT;
Пояснення до коду:
Я створила таблицю audit_log для зберігання інформації про дії, що відбуваються в базі даних. Вона має два основні стовпці:
•	Action, в якому міститься опис виконаної операції (наприклад, оновлення даних водія),
•	Timestamp, який зберігає точний час виконання цієї операції.
У транзакції я спочатку оновила дані в таблиці Driver (змінив ім'я водія на "Ivan" для водія з певним ID). Потім, щоб зафіксувати цю зміну, я додала запис у таблицю audit_log з описом змін і поточним часом виконання операції.
Це дозволяє створити надійний механізм для логування всіх змін у базі даних, що допомагає забезпечити прозорість і відстеження операцій, особливо коли потрібно контролювати або відновлювати стан системи після певних змін.
Транзакція гарантує, що операції з оновлення даних і логування будуть виконані разом або не будуть виконані взагалі, якщо з'явиться якась помилка.
 

Завдання 9. Принцип АТОМАРНІСТЬ.
У цьому завданні демонструю принцип атомарності транзакції. Він полягає в тому, що всі дії всередині транзакції повинні виконуватись як єдине ціле — або всі разом, або жодна з них. Навіть якщо виникає помилка в одній з операцій, система має скасувати всю транзакцію.
Лістинг коду:
BEGIN TRAN;

-- Вставка нового водія
INSERT INTO Driver (LastName, FirstName, Address, License_Number, License_Expiry)
VALUES ('Bondarenko', 'Oleksii', 'Kharkiv, Main St, 2', 'KH1234567', '2027-12-31');

-- Вставка ДТП (штучна помилка: передчасна кома)
INSERT INTO Accident (Date, Time, Location, Victim_Count, Accident_Type)
VALUES ('2025-04-01', '15:30', 'Kharkiv Avenue', 1, 'Collision');
-- Якщо друга операція не вдасться — вся транзакція буде скасована
COMMIT;
Пояснення до коду:
У межах транзакції я спочатку вставляю нового водія до таблиці Driver, а потім — запис про ДТП у таблицю Accident. Якщо друга операція завершиться з помилкою (наприклад, через синтаксичну помилку або обмеження цілісності), то транзакція не буде завершена, і жоден із записів не буде додано до бази. Це забезпечує цілісність даних відповідно до принципу атомарності.
 

Завдання 10. Принцип УЗГОДЖЕНІСТЬ (оновлення пов’язаних сутностей).
У цьому завданні реалізую принцип узгодженості в транзакціях. Мета — забезпечити, щоб дані в пов’язаних таблицях залишалися логічно узгодженими після внесення змін. Для цього операції додавання ДТП і постраждалих, а також оновлення кількості постраждалих об'єднані в одну транзакцію.
Лістинг коду:
BEGIN TRAN;

-- Додати нову ДТП
INSERT INTO Accident (Date, Time, Location, Victim_Count, Accident_Type, Investigation_Status)
VALUES ('2025-05-13', '17:30:00', 'Highway 12', 2, 'Collision', 'Under Investigation');

-- Отримати ID нової ДТП
DECLARE @NewAccidentID INT = SCOPE_IDENTITY();

-- Додати постраждалих
INSERT INTO Victim (ID_Accident, LastName, FirstName, MiddleName, Address, Passport_Number, Injury_Type, Severity, Hospitalization_Status)
VALUES 
(@NewAccidentID, 'Shevchenko', 'Oleh', 'Ivanovych', 'Kyiv, Peremohy Ave, 15', 'AB1234567', 'Leg injury', 'Moderate', 'Hospitalized'),
(@NewAccidentID, 'Bondar', 'Maria', 'Oleksiivna', 'Lviv, Shevchenka St, 42', 'CD7654321', 'Head trauma', 'Severe', 'Hospitalized');

-- Оновити кількість постраждалих у таблиці Accident
UPDATE Accident
SET Victim_Count = (SELECT COUNT(*) FROM Victim WHERE ID_Accident = @NewAccidentID)
WHERE ID_Accident = @NewAccidentID;

COMMIT;
Пояснення до коду:
У транзакції спочатку додається новий запис про ДТП у таблицю Accident. Далі за допомогою SCOPE_IDENTITY() отримується ID щойно доданої ДТП. Потім додаються два нові записи про постраждалих у таблицю Victim, пов’язані з цією ДТП. Після цього оновлюється поле Victim_Count у таблиці Accident, щоб воно відповідало фактичній кількості жертв. Команда COMMIT гарантує, що всі зміни набудуть чинності одночасно, зберігаючи узгодженість даних між таблицями.
 


Завдання 11. Одна транзакція – вставка + пов’язана вставка + оновлення.
У цьому завданні демонструю виконання кількох взаємопов’язаних операцій у межах однієї транзакції. Такий підхід гарантує цілісність і узгодженість даних при додаванні нових записів, які залежать один від одного.
Лістинг коду:
BEGIN TRAN;

-- Додаємо ДТП
INSERT INTO Accident (Date, Time, Location, Victim_Count, Accident_Type)
VALUES ('2025-04-10', '10:45', 'Dnipro Central', 2, 'Collision');

-- Отримуємо ID щойно доданої ДТП
DECLARE @AccidentID INT = SCOPE_IDENTITY();

-- Додаємо міліціонера, який виїхав на цю ДТП
INSERT INTO Policeman (ID_Accident, LastName, FirstName, Rank)
VALUES (@AccidentID, 'Shevchenko', 'Oleh', 'Lieutenant');

-- Оновлюємо кількість постраждалих (наприклад, помилково внесли 2, а потрібно 1)
UPDATE Accident
SET Victim_Count = 1
WHERE ID_Accident = @AccidentID;

COMMIT;
Пояснення до коду:
Транзакція починається з додавання нового запису про ДТП у таблицю Accident. Після цього, використовуючи SCOPE_IDENTITY(), зберігається ID щойно створеного запису, щоб використати його як зовнішній ключ у таблиці Policeman. Далі в цю таблицю додається міліціонер, який виїхав на місце ДТП. Наприкінці, за необхідністю, коригується кількість постраждалих у записі про ДТП. Команда COMMIT фіксує всі зміни лише в разі успішного виконання всіх кроків транзакції.


Завдання 12. Транзакція autocommit vs явна транзакція
У цьому завданні я розглянула відмінності між режимом autocommit та явною транзакцією в SQL. Такий аналіз важливий для розуміння, коли краще покладатися на автоматичне збереження змін, а коли потрібно забезпечити повний контроль над виконанням кількох взаємопов’язаних дій.
Транзакція autocommit — це режим роботи СУБД (системи управління базами даних), у якому кожна SQL-операція автоматично виконується як окрема транзакція. Після виконання команди зміни одразу фіксуються (COMMIT) в базі даних без явного запиту користувача.
UPDATE authors SET au_fname = 'John' WHERE au_id = '172-32-1176';
У режимі autocommit цей оператор:
1.	Змінює ім’я автора.
2.	Одразу після цього автоматично виконується COMMIT.
3.	Зміни зберігаються постійно в базі.
Відмінність від явної транзакції:
BEGIN TRAN;
UPDATE authors SET au_fname = 'John' WHERE au_id = '172-32-1176';
COMMIT;
У явній транзакції:
•	Ми контролюємо початок і завершення транзакції.
•	Можемо додати кілька дій у межах однієї транзакції.
•	Якщо виникає помилка — можна виконати ROLLBACK, щоб скасувати всі зміни до моменту COMMIT.
Основна різниця:
Ознака	Autocommit	Явна транзакція
Коли зберігаються зміни	Автоматично після кожної команди	Лише після COMMIT
Можна скасувати зміни	Ні	Так (ROLLBACK до COMMIT)
Гнучкість керування	Мінімальна	Повна (можна об'єднати кілька дій)
Autocommit зручно для простих, безпечних змін, але для критичних або пов’язаних дій краще використовувати явні транзакції — це дає контроль над тим, коли і що саме зберігати або скасовувати.

Висновки: 
У процесі вивчення концепції транзакцій та їх реалізації в MSSQL я ознайомилася з важливими аспектами керування даними в рамках транзакційних операцій. Транзакції є основним інструментом для забезпечення атомарності, узгодженості, ізольованості та довговічності операцій (принципи ACID). Це дозволяє гарантувати, що всі зміни або будуть успішно застосовані, або не будуть виконані зовсім у разі помилки, тим самим зберігаючи цілісність бази даних.
 Розглянула різні варіанти роботи з транзакціями: від автоматичного режиму autocommit, де кожна SQL-операція виконується як окрема транзакція, до явних транзакцій, що дають повний контроль над початком, завершенням та скасуванням операцій. Важливим елементом є використання команд BEGIN TRAN, COMMIT та ROLLBACK для керування транзакціями.
Особливо корисним було вивчення методів обробки помилок через TRY...CATCH, а також застосування точок збереження (SAVE TRANSACTION), що дає змогу відновлювати стан до конкретного моменту в середині транзакції, якщо виникли непередбачувані ситуації.
Робота з транзакціями в MSSQL допомагає забезпечити узгодженість даних у складних сценаріях, коли кілька операцій повинні бути виконані разом, і зводить до мінімуму ризики некоректних змін у базі даних.
Ці знання є важливими в галузі програмування та адміністрування баз даних, оскільки дають можливість ефективно працювати з великими об'ємами даних, забезпечуючи їх безпеку та цілісність.

Посилання на конспект:
https://docs.google.com/document/d/1cQ80CNWDVrDLPALv9pUK2ATEX58BABgg/edit?usp=drive_link&ouid=106130475242017779182&rtpof=true&sd=true

