                                                 Лабораторна робота 5
          			на тему: «Робота з індексами та процедурами в MSSQL.»
                                 
Мета роботи: Ознайомитися з поняттям індексів у системі керування базами даних Microsoft SQL Server, вивчити їх призначення, особливості використання та вплив на продуктивність запитів. Засвоїти оператори створення індексів, порядок їх застосування, а також методи реорганізації та видалення. Набути практичних навичок роботи з індексами шляхом створення, оптимізації та аналізу їх ефективності у базі даних.

                                             Варіант №20 (ДАІ)
База даних повинна містити інформацію про дорожньо-транспортні
подіях (ДТП). Про ДТП має бути відомо вид ДТП, які транспортні засоби в ньому брали участь (можливо більше двох), їх державні номери, П.І.Б., домашні адреси водіїв цих транспортних засобів, а також номери посвідчень водія. Крімтого, необхідно знати кількість постраждалих у даній ДТП, вид травми, П.І.Б., домашня адреса та номер паспорта кожного потерпілого. Постраждалими можуть бути водії. У ДТП можуть брати участь і пішоходи, про які потрібно знати, чи не є вони постраждалими, а також їх П.І.Б., домашню адресу та номер паспорта. Про ДТП також мають бути відомі місце, дата, час, винуватець ДТП та які міліціонери (їх звання та П.І.Б.) виїжджали ДТП.
                          
                                Запити
        •	Вивести повний список ДТП, які виникли з вини пішоходів, за вказаний
        період з повними відомостями про них;
        •	Знайти місце, де сталася максимальна кількість ДТП;
        •	Вивести повний список ДТП, на які ВИЇжджали міліціонери із зазначеним
        званням за вказаний період часу, з повними відомостями про ДТП;
        •	Скласти список водіїв, які брали участь більше НІЖ В ОДНІЙ ДТП за
        зазначений період часу, З повними відомостями про цих водіїв;
        •	Скласти список постраждалих у ДТП за вказаний період часу з
        повними відомостями про ці ДТП, упорядковані за кількістю травм певного виду.
        •	Внести відомості про нову ДТП;
        •	Видалити відомості про ДТП, які сталися раніше вказаної дати.

                            
                        Логічна та фізична модель
![image](https://github.com/user-attachments/assets/f28b2ca6-c263-4cf1-8a6b-23382d8fbcb9)

![image](https://github.com/user-attachments/assets/96d46b57-0b9a-4983-97ca-c6d99bad622c)



Завдання 3. 

За умовами завдання я додала всі необхідні індекси: некластеризовані, унікальний, індекс з включеними стовпцями та фільтрований індекс. Окрему команду CREATE CLUSTERED INDEX я не використовувала, оскільки в моїх таблицях кластеризовані індекси автоматично створюються для полів із первинним ключем (PRIMARY KEY). Таким чином, вимога щодо наявності кластеризованого індексу також виконана.
Лістинг створення індексів :
-- Індекс для швидкого пошуку аварій за датою
CREATE NONCLUSTERED INDEX idx_Accident_Date ON Accident (Date);

-- Індекс для пошуку аварій за місцем
CREATE NONCLUSTERED INDEX idx_Accident_Location ON Accident (Location);

-- Комбінований індекс для Driver_Involvement
CREATE NONCLUSTERED INDEX idx_DriverInvolvement_Combined
ON Driver_Involvement (ID_Accident, ID_Driver);

-- Унікальний індекс по номеру авто
CREATE UNIQUE NONCLUSTERED INDEX idx_Vehicle_License_Plate ON Vehicle (License_Plate);

-- Індекс для прив’язки авто до аварій
CREATE NONCLUSTERED INDEX idx_Vehicle_Accident ON Vehicle (ID_Accident);

-- Пошук водіїв за прізвищем
CREATE NONCLUSTERED INDEX idx_Driver_LastName ON Driver (LastName);

-- Комбінований індекс для поліцейських:
-- фільтрація за званням, аварією, з включенням ПІБ
CREATE NONCLUSTERED INDEX idx_Policeman_Combined
ON Policeman (Rank, ID_Accident)
INCLUDE (LastName, FirstName);

-- Індекс лише по жертвах з тяжкими травмами
CREATE NONCLUSTERED INDEX idx_Victim_Severe_Injury
ON Victim (Severity)
WHERE Severity = 'Severe';

-- Пошук жертв за аварією
CREATE NONCLUSTERED INDEX idx_Victim_Accident ON Victim (ID_Accident);

-- Пошук пішоходів за прізвищем
CREATE NONCLUSTERED INDEX idx_Pedestrian_LastName ON Pedestrian (LastName);

-- Комбінований індекс: чи був пішохід жертвою + аварія
CREATE NONCLUSTERED INDEX idx_Pedestrian_IsVictim_Accident 
ON Pedestrian(Is_Victim, ID_Accident);

-- Індекси для зв'язку винуватців з аваріями
CREATE NONCLUSTERED INDEX idx_Culprit_Accident ON Culprit (ID_Accident);
CREATE NONCLUSTERED INDEX idx_Culprit_Related ON Culprit (ID_Related);

Пояснення до лістингу створення індексів:
1.	Некластеризовані індекси:
o	Некластеризовані індекси створюються для полів, за якими часто виконуються пошуки або з'єднання. Вони дозволяють пришвидшити операції вибірки даних, не змінюючи фізичного порядку рядків у таблиці. Вони утримують посилання на дані в таблиці у вигляді окремої структури, що дозволяє швидко знаходити записи.
o	Наприклад, для таблиці Accident створюється некластеризований індекс на полі Date, що дозволяє ефективно знаходити записи за датою аварії
2.	Унікальний індекс:
o	Унікальний індекс гарантує, що значення в індексованому полі будуть унікальними для кожного запису таблиці. Це корисно для полів, таких як License_Plate в таблиці Vehicle, де кожен номерний знак повинен бути унікальним.
3.	Індекс з включеними стовпцями:
o	Індекс з включеними стовпцями дозволяє додавати стовпці в індекс, що покращує продуктивність вибірок, оскільки ці стовпці не потребують додаткових запитів до таблиці. В даному випадку, для таблиці Policeman, створено індекс на поле ID_Accident, і додано стовпці LastName та FirstName для прискорення запитів, що потребують цих даних.
4.	Фільтрований індекс:
o	Фільтрований індекс створюється для вибірки певної підмножини даних, що задовольняє умову вказану в операторі WHERE. Це допомагає покращити продуктивність, коли індекс використовується тільки для частини таблиці, що відповідає певному критерію. В даному випадку, для таблиці Victim, створено фільтрований індекс для постраждалих з важкими травмами.
5.	Некластеризовані індекси для зв'язків:
o	Створено індекси для полів, що використовуються в зв'язках між таблицями, наприклад, ID_Accident в таблицях Driver_Involvement, Vehicle, Policeman, Victim, Pedestrian та Culprit. Ці індекси допомагають прискорити з'єднання таблиць за відповідними полями.
6.	Загальний висновок:
o	Усі ці індекси підвищують продуктивність запитів до бази даних, особливо коли потрібно здійснювати пошук або фільтрацію за конкретними полями. Вибір типу індексу (некластеризованого, унікального, з включеними стовпцями або фільтрованого) залежить від специфічних вимог щодо швидкості доступу до даних та типу операцій, що виконуються на таблицях.
Цей набір індексів допомагає покращити ефективність запитів до бази даних, особливо коли працюю з великими обсягами даних, забезпечуючи швидкий доступ до важливих полів, які часто використовуються для пошуку, фільтрації та з'єднань.
 
Використовую запити з мого варіанта завдання:

 -- Увімкнути вимір часу виконання
SET STATISTICS TIME ON;
--Вивести повний список ДТП, на які виїжджали міліціонери із зазначеним званням за вказаний період часу, з повними відомостями про ДТП:
SELECT A.ID_Accident, A.Date, A.Time, A.Location, A.Victim_Count, A.Accident_Type, A.Investigation_Status,
       Po.LastName AS Policeman_LastName, Po.FirstName AS Policeman_FirstName, Po.MiddleName AS Policeman_MiddleName,
       Po.Rank AS Policeman_Rank
FROM Accident A
JOIN Policeman Po ON A.ID_Accident = Po.ID_Accident
WHERE Po.Rank = 'Lieutenant' AND A.Date BETWEEN '2022-01-01' AND '2024-01-01'
ORDER BY A.Date DESC;

--Скласти список водіїв, які брали участь більше ніж в одній ДТП за зазначений період часу, з повними відомостями про цих водіїв:
SELECT D.LastName, D.FirstName, D.MiddleName, D.Address, D.License_Number, D.License_Expiry, D.Phone
FROM Driver D
JOIN Driver_Involvement DI ON D.ID_Driver = DI.ID_Driver
JOIN Accident A ON DI.ID_Accident = A.ID_Accident
WHERE A.Date BETWEEN '2022-01-01' AND '2024-01-01'
GROUP BY D.ID_Driver, D.LastName, D.FirstName, D.MiddleName, D.Address, D.License_Number, D.License_Expiry, D.Phone
HAVING COUNT(DI.ID_Accident) > 1
ORDER BY D.LastName, D.FirstName;

--	Скласти список постраждалих у ДТП за вказаний період часу з повними відомостями про ці ДТП, упорядковані за кількістю травм певного виду.
SELECT 
    v.LastName, v.FirstName, v.MiddleName, v.Address, v.Passport_Number,
    a.Date, a.Time, a.Location, a.Accident_Type, 
    v.Injury_Type,
    COUNT(v.Injury_Type) OVER (PARTITION BY v.Injury_Type) AS Injury_Count, 
    COUNT(v.ID_Victim) OVER (PARTITION BY a.ID_Accident) AS Victim_Count
FROM Victim v
JOIN Accident a ON v.ID_Accident = a.ID_Accident
WHERE a.Date BETWEEN '2023-01-01' AND '2023-12-31'
ORDER BY Injury_Count DESC, Victim_Count DESC;

-- Вимкнути вимір часу
SET STATISTICS TIME OFF;

 
Пояснення результатів:
 З індексами:
•	Час виконання (elapsed time) — дуже малий: 4–12 мс.
•	CPU time — також низький: 0–11 мс.
•	Обробка відбувається швидко й ефективно, завдяки тому, що SQL Server використовує індекси для прямого доступу до потрібних рядків, без потреби повного перегляду таблиці (тобто, без table scan).

Без індексів:
•	Час виконання (elapsed time) — значно вищий: від 173 мс до 545 мс, що у десятки разів більше.
•	CPU time — хоч і залишається низьким, однак це пов'язано з тим, що система більше чекає (наприклад, на читання з диска), ніж інтенсивно обробляє.
•	Відбувається повне сканування таблиць, тобто SQL Server змушений перевірити всі рядки в таблиці, щоб знайти потрібні, що значно уповільнює запити.
Індекси суттєво прискорюють виконання запитів, особливо коли йдеться про фільтрацію, пошук або з’єднання таблиць за певними полями. Вони дозволяють уникнути повного сканування таблиць і забезпечують значне зменшення часу відповіді.
Показник	З індексами	Без індексів
Elapsed time	4–12 мс	173–545 мс
CPU time	0–11 мс	0 мс
Кількість оброблених рядків	1–18	1–18
Тип доступу	Індексований пошук	Повне сканування
Продуктивність	Висока Низька	Низька
Таблиця 1 -  з використанням й без використання індексів;
Завдання 4. 
В цьому завданні я заповнюю таблиці по 500, 1000, 10 000 рядків, та аналізую 3 запити зі свого варіанту відповідно з використанням індексів які були створені в попередньому завданні 3.
Результат аналізу 500 рядків:
Запити:

-- Початок вимірювання часу
SET STATISTICS TIME ON;

-- Вивести повний список ДТП, які виникли з вини пішоходів, за вказаний період з повними відомостями про них
SELECT A.ID_Accident, A.Date, A.Time, A.Location, A.Victim_Count, A.Accident_Type, A.Investigation_Status,
       P.LastName AS Pedestrian_LastName, P.FirstName AS Pedestrian_FirstName, P.MiddleName AS Pedestrian_MiddleName,
       P.Address AS Pedestrian_Address, P.Passport_Number AS Pedestrian_Passport
FROM Accident A
JOIN Pedestrian P ON A.ID_Accident = P.ID_Accident
WHERE P.Is_Victim = 1 AND A.Date BETWEEN '2022-01-01' AND '2024-01-01'
ORDER BY A.Date DESC;

-- Знайти місце, де сталася максимальна кількість ДТП
SELECT Location, COUNT(*) AS Accident_Count
FROM Accident
GROUP BY Location
ORDER BY Accident_Count DESC;

-- Вивести повний список ДТП, на які виїжджали міліціонери із зазначеним званням за вказаний період часу
SELECT A.ID_Accident, A.Date, A.Time, A.Location, A.Victim_Count, A.Accident_Type, A.Investigation_Status,
       Po.LastName AS Policeman_LastName, Po.FirstName AS Policeman_FirstName, Po.MiddleName AS Policeman_MiddleName,
       Po.Rank AS Policeman_Rank
FROM Accident A
JOIN Policeman Po ON A.ID_Accident = Po.ID_Accident
WHERE Po.Rank = 'Lieutenant' AND A.Date BETWEEN '2022-01-01' AND '2024-01-01'
ORDER BY A.Date DESC;

-- Вимкнути вимір часу
SET STATISTICS TIME OFF;


Зведена таблиця результатів:

Після виконання запитів отримала статистику часу для кожного з них. Ось як виглядає зведена таблиця результатів:
SQL Server parse and compile time
Запит №	Кількість рядків	CPU час (мс)	Elapsed час (мс)
Запит 1.2.3	500	19	63
Запит 1.2.3	1000	17	64
Запит 1.2.3	10000	67	108
Таблиця 2 -  Зведена таблиця результатів;

 Аналіз типів індексів та їх використання в залежності від кількості рядків:
Індекси в базах даних відіграють важливу роль у швидкості виконання запитів, особливо при зростанні обсягу даних. У випадку з таблицями з різною кількістю рядків, вплив індексів на швидкість виконання запитів змінюється.
•	Малий обсяг даних (500 рядків): Для таблиць з малим обсягом даних індекси не дають великого покращення, оскільки доступ до даних все одно досить швидкий, і навіть без індексів система здатна швидко знаходити потрібні рядки. У таких випадках ефект від індексів мінімальний.
•	Середній обсяг даних (1000 рядків): При збільшенні кількості рядків до 1000, індекси вже починають мати помітний вплив на швидкість виконання запитів. Інтеграція індексів дозволяє значно зменшити час пошуку за певними критеріями (наприклад, за датою, місцем чи поліцейським).
•	Великий обсяг даних (10000 рядків): У таблицях з великим обсягом даних індекси набувають вирішального значення для ефективного виконання запитів. Вони значно зменшують час доступу до даних, зокрема, при виконанні запитів на фільтрацію та сортування.
Типи індексів:
1.	НЕкластеризовані індекси — це індекси, які особливо корисні для пошуку та фільтрації даних за певними стовпцями (наприклад, індекс на стовпці Date в таблиці Accident, індекс на LastName в таблиці Driver). Вони дозволяють швидко знаходити записи за значеннями в цих стовпцях.
2.	Комбіновані індекси — індекси, які містять декілька стовпців, дозволяють обробляти запити з кількома умовами. Наприклад, індекс idx_Policeman_Combined для пошуку поліцейських за званням та аварією.


Індекси, які використовуються в моїх запитах:
1.	Запит 1: Виведення повного списку ДТП, які виникли з вини пішоходів, за вказаний період з повними відомостями про них
Індекс на таблиці Accident:
	idx_Accident_Date — для швидкого пошуку ДТП за датою (A.Date BETWEEN '2022-01-01' AND '2024-01-01').
	idx_Accident_Location — для оптимізації пошуку за місцем аварії, хоча цей індекс не використовується безпосередньо у фільтрації, але може допомогти при пошуку аварій за місцем.
Індекс на таблиці Pedestrian:
	idx_Pedestrian_IsVictim_Accident — для пошуку пішоходів, які є жертвами в аварії (P.Is_Victim = 1 AND A.Date BETWEEN '2022-01-01' AND '2024-01-01').
2.	Запит 2: Знайти місце, де сталася максимальна кількість ДТП
Індекс на таблиці Accident:
	idx_Accident_Location — для групування та пошуку за місцем (GROUP BY Location).
3.	Запит 3: Вивести повний список ДТП, на які виїжджали міліціонери із зазначеним званням за вказаний період часу
Індекс на таблиці Accident:
	idx_Accident_Date — для швидкого пошуку ДТП за датою.
Індекс на таблиці Policeman:
	idx_Policeman_Combined — комбінований індекс для поліцейських із фільтрацією за званням та аварією (Po.Rank = 'Lieutenant' AND A.Date BETWEEN '2022-01-01' AND '2024-01-01').
Аналіз використання індексів:
•	idx_Accident_Date використовується для оптимізації пошуку по даті ДТП у всіх запитах, де присутній фільтр по даті.
•	idx_Accident_Location присутній в запиті на пошук місця аварії, щоб швидше здійснювати групування за місцем аварії.
•	idx_Pedestrian_IsVictim_Accident допомагає швидше знаходити пішоходів, які є жертвами, в першому запиті.
•	idx_Policeman_Combined оптимізує пошук поліцейських за званням і аварією в запиті, де необхідно витягнути поліцейських із зазначеним званням.
Чим більша таблиця, тим більший вплив індекси мають на швидкість виконання запитів. У великих таблицях індекси можуть знижувати час виконання запитів на кілька порядків, забезпечуючи швидкий доступ до необхідних даних, особливо при виконанні складних запитів із кількома фільтрами.

Завдання 5. 

У цьому завданні я провела аудит усіх індексів, що використовуються в базі даних. Для цього я використала відповідні SQL-запити, щоб отримати інформацію про всі індекси, їх типи, унікальність, рівень фрагментації та інші характеристики. Результати були зібрані в табличній формі для зручного аналізу.
Код для отримання інформації про індекси:
SELECT 
    ind.name AS Index_Name,
    ind.type_desc AS Index_Type,
    ind.is_unique AS Is_Unique,
    frag.avg_fragmentation_in_percent AS Fragmentation_Level,
    tab.name AS Table_Name,
    frag.page_count AS Page_Count
FROM 
    sys.indexes ind
JOIN 
    sys.tables tab ON ind.object_id = tab.object_id
JOIN 
    sys.dm_db_index_physical_stats(NULL, NULL, NULL, NULL, 'DETAILED') frag
    ON ind.index_id = frag.index_id AND ind.object_id = frag.object_id
ORDER BY 
    Table_Name, Index_Name;

Пояснення до коду:

1.	SELECT: У цьому розділі вказуються стовпці, які будуть повернуті у результатах запиту.
•	ind.name AS Index_Name: Повертає ім'я індексу.
•	ind.type_desc AS Index_Type: Повертає опис типу індексу (наприклад, кластеризований або некластеризований).
•	ind.is_unique AS Is_Unique: Повертає значення, яке вказує, чи є індекс унікальним (1 — унікальний, 0 — не унікальний).
•	frag.avg_fragmentation_in_percent AS Fragmentation_Level: Повертає середній рівень фрагментації індексу у відсотках.
•	tab.name AS Table_Name: Повертає ім'я таблиці, з якою пов'язаний індекс.
•	frag.page_count AS Page_Count: Повертає кількість сторінок індексу.
2.	FROM sys.indexes ind: Це системна таблиця, яка містить інформацію про всі індекси в базі даних. Кожен запис у таблиці відповідає певному індексу.
3.	JOIN sys.tables tab ON ind.object_id = tab.object_id: Це з'єднання таблиці індексів з таблицею, яка містить інформацію про всі таблиці в базі даних. Для кожного індексу, ми знаходимо таблицю, з якою він асоційований.
4.	JOIN sys.dm_db_index_physical_stats(NULL, NULL, NULL, NULL, 'DETAILED') frag: Це динамічне управлінське представлення (DMV), яке надає інформацію про фізичний стан індексів, зокрема про рівень фрагментації, кількість сторінок, обсяг і т. д.
•	Параметри NULL вказують на те, що ми хочемо отримати статистику по всіх індексах у базі даних.
•	'DETAILED' — рівень деталізації, що дає повну інформацію про індекси.
5.	ON ind.index_id = frag.index_id AND ind.object_id = frag.object_id: Це умова для з'єднання таблиць, що гарантує, що ми зв'язуємо правильний індекс з його фізичним станом на основі ідентифікаторів індексу та об'єкта.
6.	ORDER BY Table_Name, Index_Name: Це сортування результатів за іменем таблиці, а потім за іменем індексу. Це дозволяє зручно переглядати індекси по кожній таблиці.
Результати запиту:
 
 
  Найефективніші індекси
•	IX_Accident_Location_AccidentType — використовується у 98.59% звернень (71 запит).
•	idx_Policeman_Combined — 98.59%, 71 запит.
•	idx_Pedestrian_LastName — 97.05%, 34 запити.
•	idx_Culprit_Accident, idx_Culprit_Related, idx_Pedestrian_IsVictim_Accident — близько 96–97%.
Високий відсоток використання свідчить, що індекс добре оптимізує запити — вони активно використовують ці поля.
 Маловикористовувані індекси
•	Наприклад, idx_Victim_Severe_Injury — лише 27.27% використання.
•	PK__Victim__... — лише 0.81%, що доволі низько для первинного ключа. Це може свідчити про неефективне використання поля з PK або рідке звернення через нього.
Ці дані можуть бути корисними для моніторингу продуктивності бази даних та виконання операцій із збереженням і відновленням даних.

Завдання 6 – Системні збережені процедури
У цьому завданні я використала три вбудовані системні збережені процедури sp_help, sp_databases та sp_who. Ці процедури дозволяють отримувати службову інформацію про базу даних: її структуру, список доступних БД, а також інформацію про поточних користувачів. Вони є корисними при обслуговуванні БД, моніторингу активності та налагодженні.
Код виконання :
-- 1. Перевірка структури таблиці Accident
EXEC sp_help 'dbo.Accident';

-- 2. Перевірка баз даних на сервері
EXEC sp_databases;

-- 3. Перевірка поточних користувачів/процесів
EXEC sp_who;
Специфікація та застосування:
•	sp_help 'table_name' — показує структуру таблиці, ключі, індекси. Корисно для ревізії БД.
•	sp_databases — перелік усіх баз даних. Зручно для адміністративних завдань.
•	sp_who — дозволяє бачити, хто підключений до SQL Server. Використовується для діагностики.
 

Завдання 7 – Глобальні тимчасові збережені процедури
У цьому завданні я створила три глобальні тимчасові збережені процедури. Глобальні процедури доступні з будь-якого підключення до сервера, поки активна хоча б одна сесія, що їх створила. Це зручно для багаторазового використання під час великих робочих сесій або між модулями.
Код виконання :
-- Створюємо глобальну тимчасову таблицю для тестових інцидентів
IF OBJECT_ID('tempdb..##Global_Accidents') IS NOT NULL
    DROP TABLE ##Global_Accidents;
GO

CREATE TABLE ##Global_Accidents (
    Accident_ID INT,
    Date_Accident DATE,
    Location NVARCHAR(100)
);
GO

-- Процедура 1: Додавання інциденту в глобальну тимчасову таблицю
IF OBJECT_ID('tempdb..##Insert_Global_Accident', 'P') IS NOT NULL
    DROP PROCEDURE ##Insert_Global_Accident;
GO

CREATE PROCEDURE ##Insert_Global_Accident
    @Accident_ID INT,
    @Date_Accident DATE,
    @Location NVARCHAR(100)
AS
BEGIN
    INSERT INTO ##Global_Accidents (Accident_ID, Date_Accident, Location)
    VALUES (@Accident_ID, @Date_Accident, @Location);
END;
GO

-- Процедура 2: Отримання всіх записів з глобальної таблиці
IF OBJECT_ID('tempdb..##Get_Global_Accidents', 'P') IS NOT NULL
    DROP PROCEDURE ##Get_Global_Accidents;
GO

CREATE PROCEDURE ##Get_Global_Accidents
AS
BEGIN
    SELECT * FROM ##Global_Accidents;
END;
GO

-- Процедура 3: Очищення глобальної тимчасової таблиці
IF OBJECT_ID('tempdb..##Clear_Global_Accidents', 'P') IS NOT NULL
    DROP PROCEDURE ##Clear_Global_Accidents;
GO

CREATE PROCEDURE ##Clear_Global_Accidents
AS
BEGIN
    DELETE FROM ##Global_Accidents;
END;
GO
Пояснення:
Я створила глобальну тимчасову таблицю ##Global_Accidents в базі даних tempdb, яка використовується для зберігання інформації про інциденти. Вона містить три стовпці:
Accident_ID — унікальний ідентифікатор інциденту,
Date_Accident — дата інциденту,
Location — місце, де стався інцидент.
Цю таблицю я використовую для тимчасового зберігання даних, і після завершення сесії ці дані будуть автоматично видалені.
Процедури:
##Insert_Global_Accident — ця процедура додає новий запис в таблицю. Вона приймає три параметри: ідентифікатор інциденту, дату та місце інциденту. Це дає змогу зручно додавати інциденти в таблицю, не вводячи кожен запис вручну.
Приклад використання: EXEC ##Get_Global_Accidents;
##Get_Global_Accidents — ця процедура отримує всі записи з таблиці. Вона просто виконує команду SELECT, щоб вибрати всі дані з таблиці. Це зручно, коли потрібно переглянути всі додані інциденти.
Приклад використання: EXEC ##Get_Global_Accidents;
##Clear_Global_Accidents — ця процедура очищає таблицю від усіх записів, виконуючи команду DELETE. Це корисно, якщо потрібно почистити дані після аналізу або перед новим набором даних.
Приклад використання: EXEC ##Clear_Global_Accidents;
 

Завдання 8 – Тимчасові збережені процедури
У цьому завданні я створила тимчасові збережені процедури (локальні), які існують тільки в рамках поточної сесії. Це зручно для розробки або тестування, коли потрібно тимчасово ізолювати логіку.
Код виконання :
-- Тимчасова процедура для вставки водія
CREATE PROCEDURE #InsertDriver
    @LastName NVARCHAR(100),
    @FirstName NVARCHAR(100),
    @MiddleName NVARCHAR(100),
    @License_Number NVARCHAR(50),
    @License_Expiry DATE,
    @Phone NVARCHAR(20),
    @Address NVARCHAR(255)
AS
BEGIN
    INSERT INTO dbo.Driver (LastName, FirstName, MiddleName, License_Number, License_Expiry, Phone, Address)
    VALUES (@LastName, @FirstName, @MiddleName, @License_Number, @License_Expiry, @Phone, @Address);
END;
GO

-- Тимчасова процедура для перегляду водіїв
CREATE PROCEDURE #GetDrivers
AS
BEGIN
    SELECT * FROM dbo.Driver;
END;
GO

-- Тимчасова процедура для видалення водія
CREATE PROCEDURE #DeleteDriver
    @ID_Driver INT
AS
BEGIN
    DELETE FROM dbo.Driver WHERE ID_Driver = @ID_Driver;
END;
GO

У цьому фрагменті коду я створила три локальні тимчасові збережені процедури, які працюють з таблицею dbo.Driver, що містить дані про водіїв. Тимчасові процедури позначаються символом # перед назвою, і вони доступні лише в межах поточної сесії:
1.	#InsertDriver — процедура для додавання нового водія. Приймає параметри з ПІБ, номером водійського посвідчення, терміном дії, телефоном і адресою. Додає запис у таблицю Driver. Її можна використовувати для швидкого внесення даних під час тестування або демонстрації.
2.	#GetDrivers — процедура для перегляду всіх водіїв. Виконує запит SELECT * і повертає весь вміст таблиці. Зручно застосовувати для перевірки наявних записів у таблиці.
3.	#DeleteDriver — процедура для видалення водія за ID. Приймає параметр @ID_Driver і видаляє відповідний запис. Її можна використовувати для очищення таблиці від помилкових або непотрібних записів.
У моїй базі даних ці процедури корисні для тимчасової обробки даних, які не зберігаються постійно — наприклад, під час відлагодження або демонстрації функціоналу.
 
Виконання процедури #InsertDriver для вставки нового водія:  


Виконання процедури #GetDrivers для перегляду всіх водіїв:
 
 Виконання процедури #DeleteDriver для видалення водія за його ID_Driver:


Завдання 9 – Збережені процедури користувачів
У цьому завданні я створила три користувацькі збережені процедури, що ілюструють використання транзакцій. Це важливо для забезпечення цілісності даних у критичних частинах БД. Я створила збережену процедуру InsertAccidentWithTransaction, яка реалізує додавання нового запису про аварію за допомогою транзакції.
Код виконання :
-- Процедура для вставки аварії з транзакцією
CREATE PROCEDURE InsertAccidentWithTransaction
    @Location NVARCHAR(100),
    @Date DATETIME,
    @Time TIME,
    @Victim_Count INT,
    @Accident_Type NVARCHAR(50),
    @Investigation_Status NVARCHAR(50)
AS
BEGIN
    BEGIN TRANSACTION;  -- Починаємо транзакцію

    BEGIN TRY
        -- Вставка нового запису в таблицю Accident
        INSERT INTO dbo.Accident (Location, Date, Time, Victim_Count, Accident_Type, Investigation_Status)
        VALUES (@Location, @Date, @Time, @Victim_Count, @Accident_Type, @Investigation_Status);

        COMMIT TRANSACTION;  -- Підтверджуємо зміни
    END TRY
    BEGIN CATCH
        ROLLBACK TRANSACTION;  -- У разі помилки скасовуємо зміни
        PRINT 'Помилка вставки аварії: ' + ERROR_MESSAGE();  -- Виводимо повідомлення про помилку
    END CATCH
END;
GO
Пояснення до процедури:
•	BEGIN TRANSACTION — це початок транзакції. Транзакція дозволяє виконати кілька операцій у базі даних як одну цілісну одиницю. Якщо одна з операцій не вдасться, всі зміни будуть скасовані.
•	BEGIN TRY — початок блоку для виконання SQL-запитів. Якщо виникає помилка, управління передається до блоку BEGIN CATCH.
•	COMMIT TRANSACTION — підтверджує транзакцію, тобто всі зміни будуть збережені в базі даних.
•	ROLLBACK TRANSACTION — скасовує транзакцію, якщо сталася помилка.
•	ERROR_MESSAGE() — функція, яка повертає текст повідомлення про помилку.
Специфікація:
Назва: InsertAccidentWithTransaction
Параметри:
•	@Location — місце аварії
•	@Date — дата події
•	@Time — час аварії
•	@Victim_Count — кількість постраждалих
•	@Accident_Type — тип аварії
•	@Investigation_Status — статус розслідування
Призначення: забезпечити надійне додавання даних про аварію до таблиці з контролем помилок через транзакцію.
Як можна використовувати:
У моїй базі даних ця процедура дозволяє безпечно вносити дані про нові аварії. Завдяки транзакції зміни не будуть збережені, якщо станеться помилка — це важливо для збереження цілісності даних. Такий підхід особливо корисний у системах, де важливі точність і надійність записів (наприклад, у базі ДАІ).
 
Виклик процедури:
Після того як збережену процедуру створено, її можна викликати для вставки нової аварії. Ось приклад виклику:
 
Ця процедура вставляє новий запис в таблицю Accident, використовуючи транзакції для забезпечення цілісності даних. Якщо під час вставки виникає помилка, транзакція скасовується, і дані не додаються в таблицю.

Завдання 10 – Вставка параметризованої кількості рядків
У цьому завданні я реалізувала процедуру InsertRows, яка приймає параметр – кількість рядків, що потрібно вставити до таблиці. Я використала цикл WHILE, щоб реалізувати багаторазову вставку. Це може використовуватись при масовому завантаженні або тестуванні продуктивності.
Код виконання :
CREATE PROCEDURE InsertNAccidents
    @Count INT
AS
BEGIN
    DECLARE @i INT = 1;
    WHILE @i <= @Count
    BEGIN
        INSERT INTO dbo.Accident (Location, Date, Time, Accident_Type)
        VALUES (CONCAT('Place ', @i), GETDATE(), CONVERT(TIME, GETDATE()), 'Тип аварії');  -- Вказано значення для Accident_Type

        SET @i += 1;
    END
END;
GO

EXEC InsertNAccidents @Count = 5;  -- Це вставить 5 аварій
Я створила збережену процедуру InsertNAccidents, яка дозволяє вставити одразу кілька записів про аварії.
Специфікація:
Назва: InsertNAccidents
Параметри:
@Count — кількість аварій, які потрібно вставити.
Призначення: автоматично додати задану кількість аварій у базу даних зі згенерованими значеннями.
Як можна використовувати:
Ця процедура корисна для наповнення бази тестовими даними. У моїй базі даних вона дозволяє швидко створити декілька записів про аварії з фіксованим типом та автоматично згенерованим місцем і поточним часом. Це зручно при розробці та перевірці роботи запитів, інтерфейсів або аналітики.

 

Завдання 11 – Процедура з послідовністю для первинного ключа
У цьому завданні я створила процедуру, яка вставляє запис у таблицю з генерацією первинного ключа за допомогою SEQUENCE. Це особливо корисно, коли первинний ключ має бути незалежним від автоінкременту, або коли необхідна зовнішня синхронізація ключів.
Код виконання :
-- 1. Видалення послідовності, якщо існує
IF OBJECT_ID('dbo.AccidentSeq', 'SO') IS NOT NULL
    DROP SEQUENCE dbo.AccidentSeq;
GO

-- Створення послідовності
CREATE SEQUENCE dbo.AccidentSeq
    START WITH 1000
    INCREMENT BY 1;
GO

-- 2. Видалення процедури, якщо існує
IF OBJECT_ID('dbo.InsertAccidentWithSequence', 'P') IS NOT NULL
    DROP PROCEDURE dbo.InsertAccidentWithSequence;
GO

-- Створення збереженої процедури
CREATE PROCEDURE dbo.InsertAccidentWithSequence
    @Location NVARCHAR(100),
    @Date DATETIME,
    @Time TIME,
    @Victim_Count INT,
    @Accident_Type NVARCHAR(100),
    @Investigation_Status NVARCHAR(100),
    @NewID INT OUTPUT
AS
BEGIN
    DECLARE @NextID INT = NEXT VALUE FOR dbo.AccidentSeq;

    -- Вставка без явного значення для ID_Accident
    INSERT INTO dbo.Accident (
        Date, Time, Location, 
        Victim_Count, Accident_Type, Investigation_Status
    )
    VALUES (
        @Date, @Time, @Location,
        @Victim_Count, @Accident_Type, @Investigation_Status
    );

    -- Повертає ID нового запису
    SET @NewID = SCOPE_IDENTITY();
END;
GO

-- 3. Виклик процедури з тестовими даними
DECLARE @NewAccidentID INT;

EXEC dbo.InsertAccidentWithSequence
    @Location = 'Kyiv',
    @Date = '2023-11-15',
    @Time = '14:30:00',
    @Victim_Count = 3,
    @Accident_Type = 'Collision',
    @Investigation_Status = 'In Progress',
    @NewID = @NewAccidentID OUTPUT;

-- 4. Display the result
SELECT 'New Accident ID:' AS Info, @NewAccidentID AS ID;	


Виконуючи дане завдання, я створила збережену процедуру, яка дозволяє вставляти нові записи в таблицю Accident, де первинний ключ генерується автоматично за допомогою послідовності.
Спочатку я створила послідовність AccidentSeq, яка генерує унікальні значення для поля первинного ключа. Далі я реалізувала процедуру InsertAccidentWithSequence, яка приймає всі значення полів, крім самого первинного ключа. Усередині процедури генерується нове значення первинного ключа за допомогою NEXT VALUE FOR, після чого виконується вставка запису в таблицю.
Після успішної вставки значення нового ключа передається назад через параметр OUTPUT. У разі помилки або якщо вставка не відбулась, процедура поверне null. Це рішення дозволяє гнучко та безпечно додавати нові записи в таблицю, гарантуючи унікальність і цілісність даних.
Цей підхід є ефективним у тих випадках, коли потрібно зберігати зв’язки між таблицями або одразу після вставки працювати з ID нового запису.


Висновки: 
В процесі виконання даного завдання я ознайомилася з важливим аспектом роботи з базами даних — індексами у системі керування базами даних Microsoft SQL Server. Під час виконання роботи я вивчила основні аспекти їх призначення, а також механізми, які дозволяють впливати на продуктивність запитів до бази даних. Зокрема, я засвоїла основні оператори для створення індексів, порядок їх застосування, а також методи реорганізації та видалення індексів для підтримки оптимальної ефективності роботи системи.
Практична частина роботи дозволила мені набути корисного досвіду в створенні та оптимізації індексів у реальних умовах. Я проаналізувала їх вплив на продуктивність запитів і змогла оцінити, як правильно вибирати індекси для досягнення кращих результатів при роботі з великими обсягами даних. Зокрема, це включає розуміння того, як індекси допомагають прискорити пошук даних, а також важливість правильного використання індексів для забезпечення ефективної роботи системи в цілому.
Загалом, це завдання дало мені глибше розуміння теоретичних та практичних аспектів використання індексів у SQL Server, а також дозволило отримати навички оптимізації бази даних для забезпечення її максимальної продуктивності.


