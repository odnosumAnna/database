                                                 ПРАКТИЧНА РОБОТА №7
          	                        на тему: « Обмеження цілісності в реляційних базах даних.»
                                 
Мета роботи: Ознайомитися з видами обмежень цілісності, що застосовуються в реляційних базах даних, та реалізувати їх за допомогою декларативного та процедурного підходів, з урахуванням часу перевірки та області дії.

                                             Варіант №20 (ДАІ)
База даних повинна містити інформацію про дорожньо-транспортні
подіях (ДТП). Про ДТП має бути відомо вид ДТП, які транспортні засоби в ньому брали участь (можливо більше двох), їх державні номери, П.І.Б., домашні адреси водіїв цих транспортних засобів, а також номери посвідчень водія. Крімтого, необхідно знати кількість постраждалих у даній ДТП, вид травми, П.І.Б., домашня адреса та номер паспорта кожного потерпілого. Постраждалими можуть бути водії. У ДТП можуть брати участь і пішоходи, про які потрібно знати, чи не є вони постраждалими, а також їх П.І.Б., домашню адресу та номер паспорта. Про ДТП також мають бути відомі місце, дата, час, винуватець ДТП та які міліціонери (їх звання та П.І.Б.) виїжджали ДТП.
                          
                                Запити
        •	Вивести повний список ДТП, які виникли з вини пішоходів, за вказаний
        період з повними відомостями про них;
        •	Знайти місце, де сталася максимальна кількість ДТП;
        •	Вивести повний список ДТП, на які ВИЇжджали міліціонери із зазначеним
        званням за вказаний період часу, з повними відомостями про ДТП;
        •	Скласти список водіїв, які брали участь більше НІЖ В ОДНІЙ ДТП за
        зазначений період часу, З повними відомостями про цих водіїв;
        •	Скласти список постраждалих у ДТП за вказаний період часу з
        повними відомостями про ці ДТП, упорядковані за кількістю травм певного виду.
        •	Внести відомості про нову ДТП;
        •	Видалити відомості про ДТП, які сталися раніше вказаної дати.

                            
                        Логічна та фізична модель
![image](https://github.com/user-attachments/assets/f28b2ca6-c263-4cf1-8a6b-23382d8fbcb9)

![image](https://github.com/user-attachments/assets/96d46b57-0b9a-4983-97ca-c6d99bad622c)

Завдання 2. Обмеження у базі даних. Їх класифікація.
Обмеження в базі даних (constraints) — це правила, які застосовуються до даних у таблицях для забезпечення їх цілісності, точності та надійності. Вони обмежують тип даних, які можуть зберігатися в стовпцях, і запобігають некоректним операціям (наприклад, дублюванню, порушенню зв’язків між таблицями тощо).
Обмеження цілісності можна класифікувати за різними критеріями:
 • За способами реалізації:
 o Декларативна підтримка: Обмеження визначаються за допомогою спеціальних конструкцій мови SQL (наприклад, PRIMARY KEY, FOREIGN KEY, UNIQUE, CHECK, NOT NULL, DEFAULT) при створенні або зміні таблиць чи доменів. СКБД автоматично забезпечує їх дотримання.  
o Процедурна підтримка: Обмеження реалізуються за допомогою програмного коду (збережених процедур, тригерів), який виконується при спробі зміни даних. Цей підхід гнучкіший, але складніший у реалізації та підтримці. 

• За часом перевірки: 
o Негайна перевірка: Обмеження перевіряється одразу після виконання кожної операції зміни даних. 
o Відкладена перевірка: Перевірка обмеження відкладається до моменту завершення транзакції (COMMIT). Це дозволяє тимчасово порушувати цілісність всередині транзакції, якщо кінцевий стан буде узгодженим.
 • За областю дії: 
o Обмеження домену: Визначає множину допустимих значень для певного типу даних (наприклад, Вік INT CHECK (Вік >= 18 AND Вік <= 65)). 
o Обмеження атрибута (стовпця): Застосовується до конкретного стовпця таблиці (наприклад, NOT NULL, UNIQUE). 
o Обмеження кортежу (рядка): Визначає співвідношення між значеннями різних стовпців в межах одного рядка (наприклад, CHECK (Дата_Закінчення >= Дата_Початку)). 
o Обмеження відношення (таблиці): Визначає властивості, що стосуються всієї таблиці або зв'язків між рядками (наприклад, PRIMARY KEY). 
o Обмеження бази даних (Assertions): Незалежні твердження, що визначають складні правила, які можуть охоплювати кілька таблиць (не всі СКБД повністю підтримують assertions зі стандарту SQL).

Посилальна цілісність
Посилальна цілісність забезпечується через зовнішні ключі (FOREIGN KEY), які створюють зв’язок між таблицями. Дії, які можуть бути визначені при видаленні або оновленні пов’язаних записів:
•	NO ACTION — заборонити операцію.
•	CASCADE — автоматично видалити або оновити залежні записи.
•	SET NULL — встановити NULL у зовнішньому ключі.
•	SET DEFAULT — встановити значення за замовчуванням.

Завдання 3. Використання транзакції за варіантом завдання про ДАІ.
 В цьому завданні розглядаю використання транзакцій у базі даних для збереження цілісності даних при внесенні нового запису про ДТП та відповідних учасників. Транзакція забезпечує атомарність всіх операцій: або всі дані додаються до бази, або жодна з операцій не виконується у разі помилки. Це дозволяє уникнути ситуації, коли частина даних була додана, а інша частина — ні, що може призвести до неконсистентності.

Лістинг коду:
BEGIN TRANSACTION;

-- 1. Додавання нової інформації про ДТП
DECLARE @NewAccidentID INT;

-- Додаємо основні дані про ДТП
INSERT INTO Accident (Date, Time, Location, Victim_Count, Accident_Type, Investigation_Status)
VALUES ('2023-05-15', '14:30:00', 'Central St, 25', 2, 'Two-car collision', 'Under investigation');

-- Отримуємо ID нової ДТП
SET @NewAccidentID = SCOPE_IDENTITY();

-- Додаємо дані про водіїв
INSERT INTO Driver (LastName, FirstName, MiddleName, Address, License_Number, License_Expiry, Phone)
VALUES ('Ivanov', 'Petro', 'Sergiyovych', 'Forest St, 10', 'AB123456', '2025-12-31', '+380501234567');

DECLARE @Driver1ID INT = SCOPE_IDENTITY();

INSERT INTO Driver (LastName, FirstName, MiddleName, Address, License_Number, License_Expiry, Phone)
VALUES ('Petrov', 'Oleksiy', 'Ivanovych', 'Garden St, 5', 'BC654321', '2024-10-15', '+380671234567');

DECLARE @Driver2ID INT = SCOPE_IDENTITY();

-- Додаємо транспортні засоби
INSERT INTO Vehicle (ID_Accident, License_Plate, Model, Year)
VALUES (@NewAccidentID, 'AA1234BC', 'Toyota Camry', 2018);

INSERT INTO Vehicle (ID_Accident, License_Plate, Model, Year)
VALUES (@NewAccidentID, 'BC5678AA', 'Honda Civic', 2020);

-- Додаємо участь водіїв у ДТП
INSERT INTO Driver_Involvement (ID_Accident, ID_Driver, Role, Involvement_Status, Fixation_Time)
VALUES (@NewAccidentID, @Driver1ID, 'Participant', 'Registered', GETDATE());

INSERT INTO Driver_Involvement (ID_Accident, ID_Driver, Role, Involvement_Status, Fixation_Time)
VALUES (@NewAccidentID, @Driver2ID, 'Participant', 'Registered', GETDATE());

-- Додаємо дані про постраждалих
INSERT INTO Victim (ID_Accident, LastName, FirstName, MiddleName, Address, Passport_Number, Injury_Type, Severity, Hospitalization_Status)
VALUES (@NewAccidentID, 'Ivanov', 'Petro', 'Sergiyovych', 'Forest St, 10', 'KM123456', 'Arm fracture', 'Moderate', 'Hospitalized');

INSERT INTO Victim (ID_Accident, LastName, FirstName, MiddleName, Address, Passport_Number, Injury_Type, Severity, Hospitalization_Status)
VALUES (@NewAccidentID, 'Sydorenko', 'Maria', 'Olehivna', 'Park St, 15', 'KM654321', 'Brain concussion', 'Severe', 'Hospitalized');

-- Додаємо дані про пішохода (винуватця)
INSERT INTO Pedestrian (ID_Accident, LastName, FirstName, MiddleName, Address, Passport_Number, Is_Victim, Phone)
VALUES (@NewAccidentID, 'Kovalenko', 'Andriy', 'Volodymyrovych', 'Shevchenko St, 20', 'KM987654', 0, '+380631234567');

-- Додаємо винуватця ДТП (пішохід)
INSERT INTO Culprit (ID_Related, ID_Accident, Type)
VALUES (SCOPE_IDENTITY(), @NewAccidentID, 'Pedestrian');

-- Додаємо дані про поліцейських
INSERT INTO Policeman (ID_Accident, LastName, FirstName, MiddleName, Rank, Department)
VALUES (@NewAccidentID, 'Boyko', 'Oleh', 'Mykhailovych', 'Senior Lieutenant', 'Kyiv Traffic Police');

INSERT INTO Policeman (ID_Accident, LastName, FirstName, MiddleName, Rank, Department)
VALUES (@NewAccidentID, 'Shevchenko', 'Vitaliy', 'Ihorovych', 'Lieutenant', 'Kyiv Traffic Police');

-- Перевіряємо наявність помилок
IF @@ERROR = 0
BEGIN
    COMMIT TRANSACTION;
    PRINT 'Transaction completed successfully. New accident data added to database.';
END
ELSE
BEGIN
    ROLLBACK TRANSACTION;
    PRINT 'Error occurred during transaction. All changes have been rolled back.';
END;
Пояснення транзакції:
1.	Початок транзакції:
o	BEGIN TRANSACTION ініціалізує транзакцію. Це означає, що всі операції, що виконуються в рамках цієї транзакції, будуть або всі успішними, або жодна не буде зафіксована в базі даних, якщо виникне помилка.
2.	Додавання даних:
o	Основні дані про ДТП: Додається запис з інформацією про ДТП, включаючи дату, час, місце, тип ДТП та статус розслідування.
o	Інформація про водіїв: Додаються дані двох водіїв, зокрема їхні ПІБ, адреси, номери водійських посвідчень, телефони тощо.
o	Транспортні засоби: Додаються дані про автомобілі, що брали участь у ДТП, включаючи їхні номерні знаки, моделі та роки випуску.
o	Участь водіїв у ДТП: Додаються записи про участь водіїв у ДТП, де зазначається їх роль та статус участі.
o	Дані про постраждалих: Додаються записи про постраждалих осіб, включаючи ПІБ, тип травм, тяжкість та статус госпіталізації.
o	Інформація про пішохода (винуватця): Додається запис про пішохода, який був винуватцем ДТП.
o	Дані про поліцейських: Додаються записи про поліцейських, які виїхали на місце події.
3.	Фіксація або відкат транзакції:
o	Якщо всі операції виконуються без помилок (перевірка через @@ERROR), то транзакція фіксується за допомогою COMMIT TRANSACTION.
o	У разі помилки в будь-якій операції всі зміни скасовуються за допомогою ROLLBACK TRANSACTION, і виводиться повідомлення про помилку.
Транзакція гарантує, що або всі дані будуть коректно внесені в базу даних, або жодних змін не відбудеться, якщо виникне помилка. Це важливо для забезпечення цілісності даних.
   


Завдання 4. Декларативна підтримка обмежень цілісності.
У цьому завданні я розглянула декларативну підтримку обмежень цілісності в базі даних. Декларативні обмеження — це механізми, які задаються безпосередньо на рівні структури таблиць і забезпечують автоматичне підтримання правильності та узгодженості даних.
Лістинг коду:
-- Завдання 4: Декларативна підтримка обмежень цілісності
-- Таблиці вже містять наступні декларативні обмеження:
-- PRIMARY KEY, FOREIGN KEY, CHECK, NOT NULL

-- Додаткові декларативні приклади:

-- Обмеження унікальності номера паспорта постраждалого
ALTER TABLE Victim
ADD CONSTRAINT UQ_Victim_Passport UNIQUE (Passport_Number);

-- Обмеження унікальності номера паспорта пішохода
ALTER TABLE Pedestrian
ADD CONSTRAINT UQ_Pedestrian_Passport UNIQUE (Passport_Number);

-- Обмеження NOT NULL для Injury_Type
ALTER TABLE Victim
ALTER COLUMN Injury_Type VARCHAR(100) NOT NULL;

-- Обмеження на тип винуватця
ALTER TABLE Culprit
ADD CONSTRAINT CHK_Culprit_Type CHECK (Type IN ('Driver', 'Pedestrian'));
Пояснення коду:
Декларативна підтримка обмежень цілісності в базах даних забезпечує автоматичне підтримання правильності, узгодженості та надійності збережених даних без потреби додаткової логіки на рівні додатка.
Основні типи таких обмежень включають:
•	Унікальність — гарантує, що значення в певному стовпці або наборі стовпців не повторюються, що є важливим для унікальної ідентифікації записів.
•	Обмеження NOT NULL — забороняє збереження пустих (NULL) значень у важливих полях, що гарантує наявність необхідної інформації у кожному записі.
•	Перевірочні обмеження (CHECK) — обмежують допустимі значення в стовпцях певними правилами або списками, що запобігає введенню некоректних даних.
•	Первинні та зовнішні ключі (PRIMARY KEY, FOREIGN KEY) — забезпечують зв’язність і цілісність даних між таблицями, підтримуючи коректні відносини між сутностями.
Таким чином, декларативні обмеження дозволяють базі даних самостійно контролювати дотримання бізнес-правил і логіки, зменшуючи ризик помилок і забезпечуючи високу якість даних.
 

Завдання 5. Процедурна підтримка обмежень цілісності.
У цьому завданні я розглянула процедурну підтримку обмежень цілісності в базах даних. На відміну від декларативних обмежень, які задаються на рівні структури таблиць (наприклад, PRIMARY KEY, FOREIGN KEY, CHECK), процедурна підтримка реалізується за допомогою спеціальних програмних конструкцій — зокрема, тригерів та збережених процедур.
Процедурні механізми дозволяють реалізувати складніші правила бізнес-логіки, які неможливо описати стандартними декларативними засобами. Вони виконуються автоматично у відповідь на певні події в базі даних (наприклад, вставка, оновлення або видалення даних), і дають змогу контролювати узгодженість, перевіряти складні умови, логіку, пов'язану з декількома таблицями, або валідувати зміни перед їх фіксацією.
Оскільки SQL Server не завжди дозволяє реалізувати всі бізнес-правила через декларативні обмеження, процедурна підтримка є гнучким і потужним інструментом для забезпечення цілісності даних.
У цьому звіті наведено опис 10 прикладів обмежень цілісності, які можна реалізувати за допомогою процедурних механізмів. Реалізація буде представлена у наступній лабораторній роботі (ЛР7), де створюватимуться відповідні тригери.
1.	Перевірка унікальності номерного знака транспортного засобу - перед додаванням нового транспортного засобу перевіряти, чи не існує вже транспортного засобу з таким самим номерним знаком. 
2.	Перевірка номера водія - перевіряти, що телефон водія має мінімальну довжину (наприклад, 10 цифр):
3.	Перевірка наявності міліціонера для ДТП - перед завершенням реєстрації ДТП перевіряти, чи призначено хоча б одного міліціонера. 
4.	Перевірка унікальності номерів паспортів - перевіряти, чи не існує вже постраждалого або пішохода з таким самим номером паспорта. 
5.	Перевірка участі водія в одній ДТП одночасно - перевіряти, чи водій не бере участь у двох ДТП одночасно (на основі часу фіксації). 
6.	Перевірка дати ДТП - перевіряти, чи дата ДТП не в майбутньому (вже реалізовано декларативно, але можна додати додаткову перевірку). 
7.	Перевірка статусу водія - перевіряти, чи водій не був постраждалим у цьому ж ДТП. 
8.	Перевірка типу винуватця - перевіряти, чи винуватець дійсно брав участь у ДТП (як водій або пішохід). 
9.	Перевірка кількості постраждалих - перевіряти, чи кількість постраждалих у ДТП відповідає кількості записів у таблиці Victim. 
10.	Перевірка терміну дії посвідчення водія - перевіряти, чи не протерміноване посвідчення водія на момент ДТП.


Завдання 6. Обмеження цілісності за часом перевірки.
У цьому завданні я реалізувала імітацію перевірки обмежень цілісності за часом у середовищі Microsoft SQL Server.
Лістинг коду:
-- Якщо constraint існує — видаляємо, щоб не було конфліктів
IF EXISTS (SELECT * FROM sys.foreign_keys WHERE name = 'fk_victim_accident')
BEGIN
    ALTER TABLE Victim DROP CONSTRAINT fk_victim_accident;
END

-- Додаємо FK з негайною перевіркою (імовірно це "IMMEDIATE" в умові)
ALTER TABLE Victim
WITH CHECK
ADD CONSTRAINT fk_victim_accident FOREIGN KEY (ID_Accident) REFERENCES Accident(ID_Accident);

-- Тепер імітуємо "DEFERRED" — відключаємо перевірку FK перед вставками
ALTER TABLE Victim NOCHECK CONSTRAINT fk_victim_accident;

BEGIN TRANSACTION;

-- Вставляємо дані без негайної перевірки FK
INSERT INTO Victim 
    (ID_Accident, LastName, FirstName, MiddleName, Address, Passport_Number, Injury_Type, Severity, Hospitalization_Status) 
VALUES 
    (21632, 'White', 'Charles', 'Q', '641 Oak Blvd', 'AB8209996', 'Burns', 'Severe', 'Outpatient');

-- Після всіх вставок примусово увімкнути і перевірити FK
ALTER TABLE Victim WITH CHECK CHECK CONSTRAINT fk_victim_accident;

COMMIT;

Пояснення до коду:
У цьому завданні я реалізувала імітацію перевірки обмежень цілісності за часом у середовищі Microsoft SQL Server, який не підтримує стандартні оператори SET CONSTRAINTS ALL IMMEDIATE та SET CONSTRAINTS ALL DEFERRED. Замість цього я використала механізм WITH CHECK і NOCHECK для керування моментом перевірки зовнішнього ключа (foreign key).
Спочатку відбувається перевірка наявності зовнішнього ключа fk_victim_accident. Якщо він існує — його видаляють, щоб уникнути конфлікту при створенні нового. Далі створюється зовнішній ключ із перевіркою (WITH CHECK), що відповідає режиму негайної перевірки обмежень — усі існуючі та нові дані автоматично перевіряються на узгодженість із пов’язаною таблицею Accident.
Для реалізації відкладеної перевірки обмежень, я тимчасово вимикаю перевірку зовнішнього ключа за допомогою NOCHECK CONSTRAINT. Це дозволяє вставити дані у таблицю Victim, навіть якщо відповідного запису у таблиці Accident ще не існує або перевірка тимчасово не виконується. Після вставки виконується повторне включення обмеження з повною перевіркою всіх даних (WITH CHECK CHECK CONSTRAINT), після чого транзакція фіксується (COMMIT).
Таким чином, код демонструє, як у SQL Server можна вручну імітувати механізми перевірки цілісності "IMMEDIATE" і "DEFERRED" за допомогою вбудованих засобів управління обмеженнями таблиці.




Завдання 7. Обмеження цілісності за областю дії.
У цьому завданні розглядаються обмеження цілісності за областю дії — це класи обмежень, які забезпечують правильність даних на різних рівнях моделі даних. Вони гарантують, що дані відповідають заданим вимогам як на рівні окремих значень, так і на рівні всієї бази даних.
•	Обмеження домена — контролюють допустимі значення для окремого типу даних або атрибута (наприклад, довжина рядка, діапазон чисел).
•	Обмеження атрибута — застосовуються до одного стовпця таблиці, наприклад, перевірка формату чи діапазону значень.
•	Обмеження кортежу — перевіряють набір атрибутів (рядок таблиці) як єдине ціле, наприклад, валідність дати чи узгодженість полів.
•	Обмеження відношення — регулюють властивості всієї таблиці (наприклад, мінімальна кількість записів із певною ознакою).
•	Обмеження бази даних — охоплюють правила, що застосовуються до всієї бази даних, такі як унікальність ключових даних серед усіх таблиць.
У T-SQL приклади обмежень домена, атрибута та кортежу реалізовані через конструкції CHECK та обмеження у таблицях. Обмеження відношення та бази даних часто реалізуються через тригери або інші механізми, які будуть розглянуті у наступних лабораторних роботах.

Лістинг коду:

-- Приклади обмежень цілісності за областю дії в одному коді

-- 1) Обмеження домена (Domain constraint)
-- Приклад: Тип ДТП повинен бути не порожнім і довжина не більше 50 символів
ALTER TABLE Accident
ADD CONSTRAINT CHK_Accident_Type_Length
CHECK (Accident_Type IS NOT NULL AND LEN(Accident_Type) <= 50);

-- 2) Обмеження атрибута (Attribute constraint)
-- Приклад: Максимальна довжина державного номера транспортного засобу - 10 символів (вже в таблиці Vehicle)
-- Для демонстрації додамо CHECK на формат номера: номер повинен містити тільки великі літери та цифри (наприклад)
ALTER TABLE Vehicle
ADD CONSTRAINT CHK_License_Plate_Format
CHECK (License_Plate NOT LIKE '%[^A-Z0-9]%');

-- 3) Обмеження кортежу (Tuple constraint)
-- Приклад: Один водій може керувати лише одним транспортним засобом в одній ДТП
-- Реалізуємо через унікальний індекс на пару (ID_Accident, ID_Driver) у таблиці Driver_Involvement (вже є PRIMARY KEY)
-- Щоб продемонструвати, створимо унікальний індекс на ID_Driver у межах однієї ДТП
-- Але він уже реалізований як PRIMARY KEY, тому приклад: додамо перевірку, що роль водія не може бути одночасно і "Driver" і "Pedestrian" в одному ДТП

ALTER TABLE Driver_Involvement
ADD CONSTRAINT CHK_Role_Valid CHECK (Role IN ('Driver', 'Pedestrian'));

-- 4) Обмеження відношення (Relation constraint)
-- Приклад: Кожне ДТП повинно мати хоча б одного міліціонера (взаємозв’язок)
-- Перевірити через тригер або перевірку наявності записів. SQL Server не підтримує FOREIGN KEY з мінімальною кількістю 1, тому приклад з тригером:

CREATE TRIGGER trg_CheckPolicemanForAccident
ON Policeman
AFTER INSERT, DELETE
AS
BEGIN
    SET NOCOUNT ON;

    -- Перевірка, чи всі ДТП мають хоча б одного міліціонера
    IF EXISTS (
        SELECT ID_Accident
        FROM Accident A
        WHERE NOT EXISTS (SELECT 1 FROM Policeman P WHERE P.ID_Accident = A.ID_Accident)
    )
    BEGIN
        RAISERROR('Кожне ДТП повинно мати хоча б одного міліціонера', 16, 1);
        ROLLBACK TRANSACTION;
    END
END;

-- 5) Обмеження бази даних (Database constraint)
-- Приклад: Дата ДТП не може бути в майбутньому
ALTER TABLE Accident
ADD CONSTRAINT CHK_Date_NotFuture
CHECK (Date <= CAST(GETDATE() AS DATE));

Пояснення до коду:
•	Обмеження домена: Тип ДТП обов’язково повинен бути заповнений і не перевищувати 50 символів, щоб уникнути некоректних або дуже довгих значень.
•	Обмеження атрибута: Державний номер транспортного засобу має містити лише великі літери та цифри — це допомагає зберігати єдиний формат для номерів.
•	Обмеження кортежу: У таблиці участі водіїв у ДТП поле Role може приймати тільки два допустимі значення — "Driver" або "Pedestrian", що гарантує коректність ролі учасника.
•	Обмеження відношення: Тригер перевіряє, щоб для кожного ДТП був призначений хоча б один міліціонер. Якщо цього немає — транзакція відміняється і видається помилка, що забезпечує цілісність зв’язку між таблицями.
•	Обмеження бази даних: Дата ДТП не може бути більшою за поточну дату, що запобігає введенню дат у майбутньому і зберігає логічну коректність даних.
 


Висновки: 
В ході виконання роботи я ознайомилася з основними видами обмежень цілісності, які використовуються в реляційних базах даних для забезпечення коректності та узгодженості даних. Було розглянуто декларативний підхід (через визначення CHECK-обмежень, унікальних індексів, FOREIGN KEY) та процедурний підхід (використання тригерів для контролю складних бізнес-правил). В процесі реалізації обмежень було враховано час перевірки даних (на рівні таблиць або на рівні транзакції) та область дії обмежень — від окремого атрибута або рядка до відношення між таблицями. Отримані знання дозволяють підвищити якість і надійність роботи бази даних, а також підтримувати логічну цілісність у системах з різними типами даних і складними зв’язками.



Посилання на конспект:
https://docs.google.com/document/d/1cQ80CNWDVrDLPALv9pUK2ATEX58BABgg/edit?usp=drive_link&ouid=106130475242017779182&rtpof=true&sd=true


